import{_ as e,c as t,o as a,a as i}from"./app.341df958.js";const p="/miniprogram/wx/2.png",r="/miniprogram/wx/3.jpg",b=JSON.parse('{"title":"双线程模型","description":"","frontmatter":{},"headers":[],"relativePath":"guide/wx-thread.md","lastUpdated":1670930745000}'),s={name:"guide/wx-thread.md"},o=i('<h1 id="双线程模型" tabindex="-1">双线程模型 <a class="header-anchor" href="#双线程模型" aria-hidden="true">#</a></h1><p>小程序的架构模型有别与传统web单线程架构，小程序为双线程架构。</p><p>微信小程序的渲染层与逻辑层分别由两个线程管理，渲染层的界面使用 webview 进行渲染；逻辑层采用 JSCore运行JavaScript代码。这里先看一下小程序的架构图。 <img src="'+p+'" alt=""></p><p>可以从图中看出，由于渲染层与逻辑层分开，一个小程序有多个界面，所以渲染层对应存在多个webview。这两个线程之间由Native层进行统一处理。无论是线程之间的通讯、数据的传递、网络请求都由Native层做转发。</p><p>那么首先有一个问题需要解释，这里的webview是什么呢？</p><p>平常我们浏览网页都是在浏览器中，可以想象webview是一个嵌入式的浏览器，是嵌入在原生应用中的。webview 用来展示网页的 view 组件，该组件是你运行自己的浏览器或者在你的线程中展示线上内容的基础。使用 webkit 渲染引擎来展示，并且支持前进后退、浏览历史、放大缩小、等更多功能。</p><p>简单来说 webview 是手机中内置了一款高性能 webkit 内核浏览器，在 SDK 中封装的一个组件。不过没有提供地址栏和导航栏，只是单纯的展示一个网页界面。</p><p>这里比较容易弄混的概念是iframe，iframe为页面中嵌入页面的方式，有别于webview嵌入原生应用的概念，这里需要注意一下。</p><p>紧接上文架构，那么为什么要做多个webview呢，为了更加接近原生应用APP的用户体验。多个webview可以理解为多页面应用，有别于单页面应用SPA，SPA渲染页面是通过路由识别随后动态将页面挂载到root节点中去，如果单页面应用打开一个新的页面，需要先卸载掉当前页面结构，并且重新渲染。很显然原生APP并不是这个样子，比较明显的特征为从页面右侧向左划入一个新的页面，并且我们可以同时看到两个页面。 <img src="'+r+'" alt=""></p><p>多页面应用就很好达到这个效果，新页面直接滑动出来并且覆盖在旧页面上即可，这也是小程序现在所做的形式。这样的用户体验是非常好的。</p><p>在之前单线程架构中，传统html开发的时候，官方建议script加载js的时候放在Body下方位置。就是因为单线程阻塞问题。因为html文件是从上到下渲染的，如果中间插入js的话，则会中断HTML节点渲染，转而去执行js，js执行完后继续渲染节点。就是因为单线程阻塞问题才建议在下方插入script，并且配合window.onload可以拿到已经渲染完成的节点。</p><p>这种情况当然也可以通过一些手段来规避，比如async、defer等。这两个属性加上后，虽然不会阻塞DOM渲染，但是并不是根本上解决问题，而是合理地安排了资源解析而已。</p>',12),_=[o];function c(n,w,d,m,h,l){return a(),t("div",null,_)}const f=e(s,[["render",c]]);export{b as __pageData,f as default};
